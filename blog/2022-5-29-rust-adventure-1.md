---
slug: rust-adventure-1
title: Rust开荒记1
authors:
  name: Criheacy
  title: Owner of this Blog
  url: https://github.com/Criheacy
  image_url: https://github.com/Criheacy.png
tags: [rust, new-tech]
---



## 从一个例子说起

现在我要写一段代码完成以下工作：

1. 创建一个字符串变量 `S1` 值为 `"Hello"`
2. 将 `S1` **浅拷贝（shallow copy）**给 `S2` 
3. 在 `S2` 的后面加上 `" World"`
4. 输出 `S1` 的值

浅拷贝不会将整个对象复制一份，而是将 `S1` 的「引用」赋值给 `S2` ，这样 `S2` 和 `S1` 指代的实际上时相同的一块字符串。因此当 `S2` 改变时，`S1` 也会随之改变；在这个例子中如果一切正常，程序应该会输出 `"Hello World"` 。

显然，各种语言都能实现上述功能。C / C++ 可以直接用指针实现浅拷贝：

```c
char s1[16] = "Hello";
char* s2 = s1;
strcat(s2, " World");
printf("%s", s1);
```

Java 因为比起前两个稍微高层一些，代码读起来也比较赏心悦目：

```java
StringBuffer s1 = new StringBuffer("Hello");
StringBuffer s2 = s1;
s2.append(" World");
System.out.println(s1);
```

:::info

需要注意的是，Java 中的 String 类型是**不可变的（Immutable）**，因此想要支持上述操作需要使用 StringBuffer。如果这里使用的是 String 类型，结果会输出 `Hello` ：Java 的 String 类型在执行 `s2 += s1` 时并非把 `s1` 的值直接添加到 `s2` 后面，而是创建了一个临时的 `s3 = s1 + s2` ，然后舍弃原来 `s2` 的值并把 `s3` 的值传给 `s2` 。

:::

这个功能实现起来很简单，各种语言实现起来基本都只是语法有少许差别。然而，如果你按照这种思路把上述代码「翻译」成 Rust 的代码，你会发现这是行不通的：

```rust
let mut s1 = String::from("Hello");
let mut s2 = s1;
s2.push_str(" World");
println!("{}", s1);
```

上述代码会在编译时报错：

```text
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:20
  |
2 |     let mut s1 = String::from("Hello");
  |         ------ move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let mut s2 = s1;
  |                  -- value moved here
4 |     s2.push_str(" World");
5 |     println!("{}", s1);
  |                    ^^ value borrowed here after move
  |
```

这是为什么？什么叫 borrow of moved value？借用了一个已经搬走的值？

## 优雅离场

先过会儿解释 Rust 编译器给出的报错，我们从另一条路入手。

上面这些代码在运行结束之后，声明的 `s1` 和 `s2` 这两个变量不再使用了。假如这是庞大系统之中的一小部分代码，我们希望这部分用来储存字符串的空间可以被回收重复利用，以后也许能用来存储其它变量。如果只分配不回收，可用的空间就会越来越少，少到以后分配变量都以及找不到足够的空间，程序就会因为空间太过狭小而「被憋死了」。这就是经典的**内存泄漏（memory leak）**问题。

那应该如何回收空间呢？注意，`s2` 是 `s1` 的**浅拷贝**，也就是说 `s2` 和 `s1` 指向的是同一块内存，引用的同一个字符串对象。如果让程序自动完成这个回收过程，`s1` 和 `s2` 会**先后分别执行一次**释放操作，这叫**二次释放（double free）**，而这是有着潜在隐患的。假如 `s1` 占用的空间在回收之后接着被分配给了另一个变量，这时再执行 `s2` 的释放操作，因为它们指向的是同一块空间，系统就会把刚刚分配出去的空间再次回收。人家另一个变量明明正常运作着却被操作系统清理掉了，将来就有可能会分配给别的对象，访问这个变量就会访问到不属于它的内容，从而引起一连串的连锁反应。而就算是 `s1` 被回收之后没有立即再被分配，根据操作系统管理内存的方式不同，「释放一块已经被释放的空间」也会导致各种不确定、难以预测的行为发生，例如之后这块内存可能被分配出去两次。总而言之，二次释放属于代码中的严重 bug，是我们都不愿意看到的。

 正确的清理方式应该是释放 `s1` 和 `s2` 其中之一，另一个便可自然失效。问题是，编译器并不知道回收哪一个，也不知道这块空间都被谁持有着。假如之后我让 `s3 = s2` ，又让 `s4 = s3` ，一块空间被引用出去很多次，编译器是找不回这所有的引用者的，也就没法确定一个变量离开作用域后应不应该释放它的内存，这个过程只能由作为程序员的你来完成。而屏幕前的你是人类（不出意外的话应该是），你需要在大脑中完成这复杂的编译过程找到所有的引用对象，然后在正确的时间正确的位置精准将他们释放掉。少释放一个就会 memory leak，多释放一个就会 double free，你承担着至关重要、但也不能出错的工作。

部分比较原始的语言（例如 C / C++）都采用了这种方式，把变量的生杀大权交给你自己。理论上只要你不出错，程序可以以非常高效的方式健康运行。然而这极其考验程序员的内力，因为一旦出错并不会立即出现故障，往往因为各种并发症导致各种看不懂的出错信息，常常会让程序员陷入无休止的 debug 中。

## 垃圾回收车

在受够了与内存管理斗智斗勇之后，以 Java 为代表的语言提出了另一种策略：在你忙于解决问题的同时，它在你的程序下面停放了一辆「垃圾回收车」。这个垃圾车只负责定期回收空间，它会主动拜访每一块空间，如果发现它不再被使用就把它装车拉走。这在 Java 中叫 Garbage Collector（GC），它会伴随你的程序一起运行在 JVM 中（有关 GC 的机制可以参考 Java 的相关文档，这里就不多说了）。其他一些语言例如 javascript 、python 也有类似的垃圾回收机制。

有了它，你就可以不再操心释放内存的问题了。不过也正因为垃圾回收这一伴生程序与真正处理逻辑的代码一起运行，它会分走一些 CPU 性能，导致这些语言的代码效率受损，运行起来没有底层语言那么快。在一些逻辑相对简单的地方（比如上面拼接 `"Hello World"` 的程序）程序员是可以看出需要回收哪些空间从而手动执行释放的，但在有 Garbage Collection 机制的语言中通常都不允许你手动释放内存，而需要等待垃圾车统一管理，这就又减少了性能上的优化空间。

除此之外，还有一些比较小众的解决方式。C++ 11 中新提出了一种「智能指针」的概念，可以使用 `std::shared_ptr` 来管理引用对象。它会在对象内部记录「有多少引用正在指向这个对象」这个数值，将其赋值可以增加 1，引用失效会减少 1，当它检测到这个值为 0 时便可自动删除。这种策略并没有把问题彻底解决，代码中仍然有可能存在「互相引用」的对象释放不掉，同时这种策略毕竟多分配了储存空间也多做了检查运算，多多少少会对性能产生影响。

多少年来程序员们在开发难度和性能之间反复取舍，想出了各种方案，然而自动管理就牺牲运行时性能，手动管理就增加代码开发难度，一部分程序员自认为有足够的功力就去啃 C 这块硬骨头，另一部分则想办法优化 GC 的性能，让它尽可能少占一些性能。然而无论哪种方式都并不能做到尽善尽美，这似乎成为了一对不可调节的矛盾。

直到 Rust 出场。

## 所有权

Rust 采用了一种与之前所有语言都不同的处理方式。还是之前的任务：

```rust
let mut s1 = String::from("Hello");
let mut s2 = s1;
s2.push_str(" World");
println!("{}", s1);
```

因为在 Rust 中 String 不是固定长度的基本类型，因此 Line 2 的赋值默认只会进行浅拷贝，这样 Line 1~2 创建了 `s1` 和 `s2` 两个指向同一个对象的 String，如果不做处理就即将面对前面的 double free 问题。Rust 为了避免这个问题，一旦将 `s1` 赋值给别的对象 `s2` ，它会立即让 `s1` **失效**；此时再想要输出 `s1` 的值，就会编译失败： `s1` 已经被**「移交（move）」**给了其它变量。

```text
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:20
  |
2 |     let mut s1 = String::from("Hello");
  |         ------ move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let mut s2 = s1;
  |                  -- value moved here
4 |     s2.push_str(" World");
5 |     println!("{}", s1);
  |                    ^^ value borrowed here after move
  |
```

既然 `s1` 已经失效，当 `s1` 离开作用域时自然不需要释放内存，只需要等待有效的 `s2` 释放内存即可。

这就是 Rust 著名的「所有权」机制。每一个时刻，只能唯一的变量持有一个对象的所有权，同时也只有持有所有权的变量离开作用域时才会释放对象占用的空间，于是同一个对象的空间就只会被释放一次。失去对象所有权的变量离开作用域时不会对对象本身产生任何影响：

```rust
let s1;
{
    let s2 = String::from("Hello");
    s1 = s2;
}
println!("{}", s1);
```

在 Line 5 ，`s2` 离开作用域时，因为 `"Hello"` 这个字符串的所有权已经被移交给了 `s1` ，所以 `s2` 不拥有任何变量的所有权，因此 `"Hello"` 这个对象并不会被释放，也能正常被输出。

此外，调用函数时会（隐式地）将变量赋值给对应的形参，这个过程也会发生所有权的转移：

```rust
fn main() {
    let s1 = String::from("Hello");
    let len_s1 = get_length(s1);
    println!("{} {}", s1, len_s1);
}

fn get_length(s: String) -> usize {
    return s.len();
}
```

Line 3 调用了 `get_length` 这个函数，其中会发生变量 `s1` 向 `s` 的赋值，而这会将 `s1` 的所有权移交给 `s` ；随着 Line 9 子函数结束，`s` 离开作用域，因为它持有字符串对象的所有权因此将字符串空间释放，回到主函数中 `s1` 就已经失去了所有权因而无法输出。因此上述程序会编译出错：

```text
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:4:23
  |
2 |     let s1 = String::from("Hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let len_s1 = get_length(s1);
  |                             -- value moved here
4 |     println!("{} {}", s1, len_s1);
  |                       ^^ value borrowed here after move
  |
```

想要解决这个问题也不难，注意到函数不仅在调用时会进行隐式赋值，在返回时也会将返回值隐式赋值给接受函数返回值的变量。利用这一点，我们可以将函数参数的所有权移交回去：

```rust
fn main() {
    let s1 = String::from("Hello");
    let (len_s1, s1) = get_length(s1);
    println!("{} {}", s1, len_s1);
}

fn get_length(s: String) -> (usize, String) {
    return (s.len(), s);
}
```

发现了吗？如果你没有遵照所有权模型，在编译时就会报错，Rust 对于所有权的检查是在编译时进行的。也就是说，它不仅能把你原来运行时产生的各种内存管理异常提前到编译时解决，而且整个所有权检查机制只会影响编译过程，不会对运行时产生性能影响。

如果你是第一次接触所有权模型，你也许会跟我一样被这种全新的变量空间管理方式震惊到，觉得它实在超出了一般的编程思维逻辑，然后仔细一想又好像有点道理。停下来仔细想一想，然后再继续阅读下面的内容。
