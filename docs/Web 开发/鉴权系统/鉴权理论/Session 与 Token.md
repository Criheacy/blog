---
title: Session 与 Token
sidebar_position: 1
---

# Session 与 Token

一个完善的鉴权系统应该具有以下几种功能：

- 用户能通过用户名和密码（或其它认证方式）登录账户
- 用户可以主动退出登录
- 访问受限制的资源前需要先验证用户身份和权限，只有允许的用户才会放行
- （可选）登录成功后一段时间内，用户再次打开网站时无需用户名和密码即可进入登录状态

下面介绍两种最常见、也是最常用的鉴权系统：基于 Session 的授权系统，以及基于 Token 的授权系统。它们都可以实现上述全部功能。

:::note

很多资料中把 Session 授权系统也叫做 Session-Cookie 授权系统（Session-Cookie based authorization system），这样同时指明了 Session ID 在本地的储存方式。单从理论来说，我认为 Session 和 Token 这两种的根本区别在于这两者生成令牌的含义不同，从而导致了会话信息一个存储在服务器，一个在客户端。因此为了聚焦于令牌本身而不是客户端的储存方式，在本文中只使用令牌的名称来代表这两者。

:::

假设现在有一个授权服务器可访问的数据库表（User），其中存储了用户名、密码、邮箱等信息（具体怎么存储的，如何避免密码明文存数据库之后再讨论），它支持检验给定的用户名和密码是否能够对应到唯一用户，如果能找到就把用户信息返回给授权服务器。

## Session

### 运作流程

1. 用户想要访问一个要进行权限验证的资源，于是用户将自己的用户名和密码发送给服务器，表明自己的身份；
2. 服务器从数据库 User 表中查找用户名和密码是否正确。如果错误，发送授权失败的信息给用户，本次授权终止；
3. 如果正确，就将用户信息内容存入一张叫**「用户会话（User Session）」**的新表中；
4. 服务器根据这条用户信息和时间戳等生成一个随机 ID ，称为 **Session ID**，作为这条数据的主键；
5. 服务器通过 response header 中的 Set-Cookie 标头将这个 Session ID 发送给用户。登录过程完成。
   - 如果客户端是浏览器，浏览器会自动解析 Set-Cookie 中的内容存入浏览器本地的 Cookie 存储中。这个 Cookie 存储不会随着刷新网页或关闭浏览器而丢失，会一直存在直到内部设定的时间到期而失效；
6. 用户再次访问需要权限验证的资源，同时在 request header 中的 Cookie 标头中附带自己刚从服务器获得的 Session ID；
7. 服务器从标头中解析获得客户端提供的 Session ID，并用它去 User Session 表中检索：如果找到了则证明这个 Session ID 是合法的，将需要的资源发送给用户；如果没找到则证明这个 Session ID 不合法或已过期，需要用户重新登录；
8. 此后若用户再次访问别的资源，重复 6-7 步骤。

### 特性

- 授权信息存储在**服务端**（这也被成为**「有状态的（stateful）」**）。正因如此：
  - 服务端可以随时撤销对用户的授权，只需要服务端删掉 User Session 表中的某条记录即可。
  - 每次带有授权的请求几乎都需要访问一次 User Session 表：这可能会造成一些性能问题，实践中经常把 Session 表放在 Redis、Memcached 之类缓存数据库中以提高访问速度。
  - 当一个网站承接的用户量非常大时，Session 表也随之变得十分巨大，可能需要考虑分布式数据库之类的方案（而横向扩展一般是比较困难的）。
- 天然对浏览器适配，因为主流的浏览器都会自动解析 Set-Cookie 中的数据存入 Cookie，并在以后访问同源网站时自动把 Cookie 中的数据附在这次请求的标头上。
  - 不过换句话说，其它平台的客户端就不一定天然适配，可能就需要自己手动解析标头完成上述逻辑。
  - 可以有效防止 XSS 攻击，不过可能存在 CSRF 攻击漏洞（见 Cookie 存储特点）。
  - 因为浏览器的浏览器每次访问时都会自动附带所有 Cookie，当 Cookie 过多时可能会增加网络包大小。

## Token

### 运作流程

（前两步与 Session 相同）

1. 用户想要访问一个要进行权限验证的资源，于是用户将自己的用户名和密码发送给服务器，表明自己的身份；
2. 服务器从数据库 User 表中查找用户名和密码是否正确。如果错误，发送授权失败的信息给用户，本次授权终止；
3. 如果正确，则服务器用自己的**私钥**对用户信息数据进行**签名**，并将用户数据连同签名一起发送给客户端（这里的发送没有标准格式，可以直接在响应体（response body）中用 json 格式发送），称为 token（译为「令牌」）；
   - 注意这里用户数据和签名是一起传输的，不是只传递签名不传用户数据，因此客户端可以得知当前用户的身份信息从而显示出来。
   - **签名**可以理解为把用户数据和**私钥**拼接后一起做一次 hash 算法。因为 hash 算法的单向性，用户收到签名后无法反推出私钥；用户也无法私自篡改自己的信息数据，因为服务器可以将用户传来的数据和**自己的**私钥再做一次 hash 算法，检查结果与签名是否相同，从而判断数据是否被篡改过。因为用户没有私钥，所以无法生成正确的签名，也就无法通过检验。也就是说，用户对身份信息数据是**只读**的。
4. 客户端将 token 妥善保管好，在下次请求时附带自己的 token（同样没有标准的发送格式，通常将其附带在 request header 中的 Authorization 标头中，用 Bearer <token\> 的格式发送）；
5. 服务器将用户数据和签名从标头中的 token 中解析出来，用自己的密钥对用户发来的用户数据进行签名，然后与用户发来的它持有的签名比对：若相同则须验明数据中是否过期等条件，全部通过后身份认证成功；否则身份认证失败，可能是签名已过期或身份信息被篡改，需要用户重新登录。

### 特性

- 服务端**不**存储授权信息（这也被称为「无状态的（stateless）」）。正因如此：
  - 服务端验证 token 时无需访存，只需执行特定的加密算法即可，没有 IO 的瓶颈，速度通常要比访存快。
  - 即使用户数量非常多，服务器也无需为此负担额外的存储压力，每个用户各自存储自己的身份信息即可。
  - 服务器**很难收回**某一特定用户的授权信息。一旦 token 发出，服务器只能寄希望于客户端主动丢弃 token 或等待其自然失效（更改服务器密钥会使得所有用户的 token 全部失效，无法分开控制单一用户）。一种办法是在服务端维护一个「黑名单」表用来储存被撤销但未过期的 token，但这又增加了访存的代价，需要在每次访问时访存来确认 token 不在黑名单里。既然都访存了那为什么不用 session 呢？

- 因为 token 中的用户会话可能会带有一些用户信息，因此如果用户在使用 token 期间更新了自己的用户资料，就有可能出现 token 中的资料和实际用户资料不一致的问题。这就需要额外的成本去维护更新 token 本身。
- 在多个客户端之间比较通用。
  - 换句话说，浏览器并不会像 Cookie 一样帮忙完成整个过程，无论是哪个端都可以共用一套处理逻辑。
  - 少了浏览器的「帮倒忙」，基于 token 的授权因此能够有效防止 CSRF 攻击。
  - 如何妥善储存 token 成为了一个问题。看似 Local Storage 是一个不错的储存场所，但由于 Javascript 代码可以自由访问其中的内容，因此有可能造成 XSS 攻击漏洞。设想这样一种场景：黑客在一个基于 token 授权的网站上发布了一篇带有 Javascript 脚本的内容，你点开了这篇文章内容的钓鱼链接，这篇内容经由你的浏览器呈现给你。而恰好你的 token 存在 Local Storage 中，而黑客的脚本文件就会自动读取 Local Storage 中的内容并构建带有 token 的恶意请求。因为脚本代码来自于服务器，因此浏览器认为这是安全可执行的，而服务器又认为这是一次正常的附带 token 的请求，黑客的 XSS 攻击成功骗过了双方。

### [JWT](https://jwt.io/)

JWT 全称为 JSON Web Token，是一种 token 的格式。前面介绍过，从原理上来说 token 中需要附带用户会话信息和签名，而并没有指定这两者应该以什么方式存放在 token 中，这就导致各个网站的 token 格式都不相同。为了标准化和简化开发，一种叫 JSON Web Token 的 token 的格式化方法横空出世，逐渐成为了 token 的标准格式。

顾名思义，JWT 是以 JSON 格式储存的数据，其中的内容由三部分构成：

- Header 标头：储存类型和格式信息

  ```json
  {
    "alg": "HS256",	// 使用 HS256 算法进行签名
    "typ": "JWT"		// JWT 类型
  }
  ```

- Payload 数据：储存用户会话相关信息

  ```json
  {
      "iss": 1627384950,			// Issuer 颁发者
      "sub": "user session",		// Subject 主题
      "aud": 1234567890,			// Audience 接收者
      "exp": 1652918400000,		// Expiration Time 过期时间
      "nbf": 1652832000000,		// Not Before 启用时间
      "iat": 1652572800000,		// Issued At 颁发时间
      "customKey": "customValue"	// 自定义字段
      	// 以上均为可选字段（非必须）
  }
  ```
  
  有关标准字段的详细信息可以查看[这篇文档](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1)。

- Signature 签名：服务器对以上两项的签名

生成 JWT 时，先填写好数据，然后使用 base64 编码将 Header 和 Payload 部分分别进行编码，编码后用 `.` 连接作为 JWT 的前半段；然后使用 Header 中指定的算法类型对整个前半段加密得到后半段，将前半段与后半段通过 `.` 再次连接得到最终结果。

```javascript
const data = base64.encode(token.header) + "." + base64.encode(token.payload);
const signature = sign(token.header.alg, data);
return data + "." + signature;
```



## 两者的区别

Session 和 Cookie 的核心区别在于**会话信息储存的位置**不同。Session 的用户会话信息存在服务端的 User Session 表中，Token 的用户会话信息存在编码后的 Token 中。因为服务端是安全的，而用户可能会篡改客户端中储存的数据，因此 token 需要在服务端签名发放，从而使客户端对其变成只读的。

此外，在本地客户端储存的方式也是这两种常见的鉴权系统的区别。有关于浏览器储存令牌的几种方式和它们之间的比较可以查看[这篇文章](../前置知识/浏览器如何储存数据)。

:::info

也许你会问，token 能不能通过 Set-Cookie 的方式传输？同样的，Session ID 能不能通过响应体来发送并储存在 Local Storage 中？

当然可以，这取决于你自己应用服务器和客户端约定的通信方式。上面说的 Session-Cookie 和 Token + Local Storage 两种授权方式其实都是「服务端令牌类型」和「客户端储存方式」的结合，服务端可以有 Session ID 和 token 两种令牌，客户端也有 cookie 和 local storage 两种储存方式，因此交叉换一下肯定也是可以的。只不过目前的这两种组合是比较通行的方式，大部分网站应用都在使用，日常交流中也都是代指这两种组合，另外的组合比较少见。

:::

## 两种方式的共同点

- **这两种方式都是为了方便，并没有提升任何的安全性。**有了它们，用户就不用在每次访问授权资源时都提供用户名和密码；但无论是窃取了 Session ID 还是 token，黑客都能凭借它伪装成用户的身份执行操作。
  - 它们可能会在用户层面上让人安心：如果将密码暴露出来会容易被别人看到从而窃取，但 Session ID 和 token 都是无意义的长字符串，对人来说记忆起来比较困难。
- 这两者都有存在时间（expired time）限制：
  - 这至少让它们被窃取后可用时间缩短，黑客只能在有限的时间内执行相对有限的操作，想要长期获得授权需要重新提供用户名和密码。
  - 这同时也降低了用户体验。在一些权限不太重要的应用中，在 token 或 session 即将过期时，服务器可以通过重新发送 Set-Cookie 或使用约定好的方式更新授权信息，从而使用户一直在系统操作时不会因为身份突然过期而打断操作流程。

## 如何选择

我知道你已经听惯了「根据实际情况选择」这种套话，而如果你已经完整阅读了上面的流程介绍和特性，相信你已经清楚了这两种授权方式的优缺点，就可以自己做出判断了。如果你只想让我推荐一种**我认为的**「最优」方案，我会推荐：

**使用 Session 作为首要的鉴权方式，使用 JWT 作为辅助。**

关于这句话中的「辅助」，一方面是在独立模块中，例如重置密码时需要发送邮箱验证码，在用户输入正确的邮箱验证码后，服务器会提供一个临时的、只针对「重置密码」单一业务的 token，此后用户就可以在提供新密码的同时附带 token 作为身份认证。另一方面，为了 预防 CSRF 攻击，许多无需第三方验证码但具有一定危险性的操作（例如注销用户、解散项目等），若是只用 session 就比较容易受到攻击；此时网站就需要客户端提供用户账号密码，密码正确时提供一个临时性的 token，从而实现「双保险」。

为什么选择 session 而不是 token 呢？我给出几点推荐的理由：

- 无论从逻辑上说还是从安全上考虑，用户的会话都应该保存在**服务器**而不是客户端。
- Session 具有服务端的强制登出能力（踢人下线），这是非常重要的。
  - 许多 SSO 登录系统在单点登录的同时也需要单点登出，这就所有子服务都支持登出的接口。
  - 一旦数据泄露，基于 session 的鉴权系统可以立即在服务端删掉 Session ID 强制登出，而 token 无能为力，只能干等它失效。
- CSRF 比 XSS 防护起来容易，比如上面就提供了一种解决方案（当然实际情况也要比这个复杂一些）。浏览器是一道天然的屏障，有效防止了恶意脚本随意访问 cookie 数据。
- Session 最难的地方在于高并发之后的服务器横向扩展，然而绝大多数的应用根本达不到那个数据量，所以不用过于担心。当你的应用真正需要横向扩展了，你的开发团队肯定也具有了一定的规模和足够的技术能力。

大多数网站也都是这样选择的，例如 Google，GitHub，Stackoverflow，当然它们具体的授权方式会比这个复杂得多。始终记住，密码才是最安全最值得信任的授权方式。如果你的网站对安全性要求很高，你可以像上面说的一样，在重要的操作前不仅要验证 session，还要向用户索要他的密码做进一步验证。比起这一点点输入密码的小麻烦，相信用户是会体谅你在防护他数据安全方面的良苦用心的。