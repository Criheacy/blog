---
sidebar_position: 3
title: 浏览器如何储存数据
---

# 浏览器如何储存数据？

设想一下：**「自动登录」**是很多网站都具备的一个功能。为了优化用户体验，用户在第一次访问登录网站后，在一定时间内再次打开网站时无需重新输入用户名和密码就已是登录状态。这个过程实际上是浏览器「记住」了你的登录数据，从而能在下一次访问相同网站时自动把登录数据发送到服务器完成登录认证。

所以「自动登录」的核心问题是，浏览器如何**储存**数据。这里的储存不是说存在变量里那么简单，它要求数据不会在网页刷新时丢失，不会随着浏览器关闭和电脑关机丢失，可以长期存储一直到它指定的过期时间之后自动销毁。

显然这就要求数据要存在硬盘（外部存储）上。然而，作为时时刻刻与形形色色的互联网打交道的浏览器，它是不会轻易给网站代码读写硬盘的权限的（要不然网站一个请求直接把你整个硬盘全传上去不就被看光了）。网站上的脚本只能用它规定好的方式来存储有限的临时数据，大概包括下面三种：

## Local Storage

- 5 MB 的大小（有些浏览器是 10 MB）
  - 一般需要存储的都是纯文本或者 ID 之类的字符串，对它们来说这个空间是非常充足的
- 每个域名之间的 Local Storage 是分离的，网站上的脚本只能访问同一域名下的 Local Storage
  - 不同协议、端口之间也是不共享的，例如 http://example.net 与 https://example.net 之间、http://example.net:80 与 http://example.net:8080 之间都不共享
- 默认情况下浏览器不会与之交互，需要在 Javascript 中使用 `Window.localStorage` 手动读写


:::caution

换句话说，只要是网站上的脚本代码，就都可以访问 local storage 中的内容，浏览器不会对这一过程做限制。然而，网站上的脚本代码并不一定都是安全的。假如你的网站允许用户上传一些内容，一些黑客就可能在上传的内容中夹杂恶意脚本，从而在其它用户下载这部分内容时用附带的恶意脚本读取他们 local storage 中的内容，达到窃取信息的目的。这种攻击方式叫做 XSS（Cross-Site Scripting）攻击。

:::

## Session Storage

- 与 Local Storage 相同，5 MB 的大小（有些浏览器是 10 MB）
- **仅在浏览器窗口打开时有效**，窗口关闭或浏览器关闭时清空
  - 窗口刷新或恢复（浏览器一段时间后清除网页内容缓存，用户点击时恢复网页）时**不会**清空
- 每个**窗口**间的 Session Storage 是分离的，就算是两个窗口中打开了同一网站，Session Storage 也不会共享
  - 同样的，不同域名、协议、端口之间都不共享
- 使用 `Window.sessionStorage` 手动读写

## Cookie

- 4 KB 的大小（相比上面两者就显得捉襟见肘）
- Cookie 通过服务端发回响应头中的 `Set-Cookie` 字段来设定，并在每一次请求中通过 `Cookie` 请求头**自动**附带上**所有的** Cookie；整个过程会由浏览器自动完成


:::caution

但因为这个过程太「过于自动」了，黑客可能会构造一个看似普通的网页，但实际隐含一个向服务端发送恶意请求的链接。一旦链接被触发，浏览器检测到这个链接访问的网站存在同源的 Cookie，就会在这次恶意请求中自动附带上用户之前保存过的 Cookie 信息，从而在用户毫无察觉的情况下「盗用」了用户的身份执行了恶意请求。这种攻击被称为 CSRF 攻击。

:::

- 不同域名之间的 Cookie 是独立的；浏览器只会发送服务器所在域下的 Cookie
- Cookie 含有一些标签（flags）：
  - `Secure`：指明这个 Cookie 只会附带在 HTTPS 请求中，未加密的 HTTP 请求不会附带
  - `HttpOnly`：这个 Cookie 无法通过 Javascript 代码通过 `Document.cookie` 读写，整个 Cookie 设定和发送的过程无法被网站脚本干预（这在一定程度上防止了上述的 XSS 攻击）

根据它们的特点，local storage 和 cookie 显然更适合存放用户认证相关的数据，而 session storage 一般都临时性地存放一些网页样式之类。关于这两者具体怎么用，下文会有详细介绍。

